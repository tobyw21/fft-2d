#![allow(unused)]


/// maths libs
use libm;
use num::complex::Complex;


/// standard libs
use std::f64::consts::PI;
use std::i128;
use std::io::Cursor;
use core::default::Default;


/// libs for read images properly
/// jpg, png has its own encoding
/// need to parse the encoding
/// inorder to get correct rbg vectors
use image::io::Reader as ImageReader;
use image::imageops::FilterType::Nearest;
use image::{GenericImage, Pixel, Pixels, DynamicImage};


/// open a image file
/// return a dynamic image enum
/// input: filename
pub fn read_img(filename: &str) -> DynamicImage {
    let mut img = ImageReader::open(filename)
    .expect("Unable to open img file")
    .decode()
    .expect("unable to decode image")
    ;

    img
}

/// check if given number is base of 2
/// input n: int
fn is_base2(n: u32) -> bool {
    if (n & (n - 1)) == 0 {
        true
    } else {
        false
    }
}

/// resize image to the closest dimension
/// fft requires the dimensions of vectors to be base of 2
/// input
/// image: image object
/// height: int
/// width: int
fn img_resize(img: &mut DynamicImage, height: &mut u32, width: &mut u32) {
    let mut original_height = *height as f32;
    let mut original_width = *width as f32;

    let mut new_height = 2;
    let mut new_width = 2;

    let mut counter_r = 0;
    let mut counter_c = 0;

    while original_height / 2.0 > 1.0 {
        original_height /= 2.0;
        counter_c += 1;
    }

    while original_width / 2.0 > 1.0 {
        original_width /= 2.0;
        counter_r += 1;
    }

    while counter_c > 0 {
        new_height *= 2;
        counter_c -= 1;
    }

    while counter_r > 0 {
        new_width *= 2;
        counter_r -= 1;
    }
    
    *height = new_height;
    *width = new_width;
    img.resize(new_width, new_height, Nearest);

}

/// https://cs.uwaterloo.ca/~kogeddes/cs487/LectureMaterials/Chapter_4_Materials/FFTalgorithm.pdf
/// this is for fft a 1 dimensional vector
/// input
/// a: vector of complex numbers with im part 0
/// ifft is a flag to indicate if the value is inverse fft
/// changes vector reference `a' passed in to fourier coefficients generated by fft
fn fft_1d(a: &mut Vec<Complex<f32>>, ifft: bool) {
    let n = a.len();

    if n == 1 {
        return;
    }

    let mut a1: Vec<Complex<f32>> = vec![Default::default(); n >> 1];
    let mut a2: Vec<Complex<f32>> = vec![Default::default(); n >> 1];

    for i in (0..n).step_by(2) {
        a1[i >> 1] = a[i];
        a2[i >> 1] = a[i + 1];

    }

    fft_1d(&mut a1, ifft);
    fft_1d(&mut a2, ifft);

    let im_conjugate = if ifft {
        1.0
    } else {
        -1.0
    };

    let wn: Complex<f32> = Complex::new((2.0 * (PI as f32) / n as f32).cos(),
        im_conjugate * (2.0 * (PI as f32) / n as f32).sin());
    
    let mut omega = Complex::new(1.0, 0.0);

    for i in (0..n >> 1) {
        a[i] = a1[i] + omega * a2[i];
        a[i + (n >> 1)] = a1[i] - omega * a2[i];
        omega *= wn;
    }
    
}

pub fn fft_2d(img: &mut DynamicImage) {

    let mut width = img.width();
    let mut height = img.height();


    if !is_base2(width) || !is_base2(height) {
        println!("image dimensions must be in base of 2, currently {} x {}, resizing...", width, height);
        img_resize(img, &mut width, &mut height);
        println!("resized to {} x {}", width, height);
    }


}

/*
fn num_base2(n: u32) -> i32 {
    let mut result = 0;
    let mut num = n;
    
    while num != 1 {
        if num % 2 == 0 {
            result += 1;
            num /= 2;
        } else {
            result = -1;
            break;
        }
    }

    result
}
*/

/*
 *    +==========================+
 *    |   macros!                |
 *    +==========================+
 */

macro_rules! cmplx_new {
    ($re: expr, $im: expr) => {
        {
            Complex::new($re, $im)
        }
    };
}

macro_rules! cmplx_push {
    ($vec: expr; $re: expr, $im: expr) => {
        $vec.push(cmplx_new!($re, $im));
    };

    ($vec: expr, $cmplx: expr) => {
        $vec.push($cmplx);
    }
}

/*
 *   +==========================+
 *   |   test sections          |
 *   +==========================+
 */

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_is_base2() {
        assert_eq!(is_base2(8), true);
    }

    #[test]
    fn test_not_base2() {
        assert_eq!(is_base2(9), false);
    }

    #[test]
    fn test_fft1d() {
        let mut test_data = Vec::new();

        cmplx_push!(test_data; 1.0, 0.0);
        cmplx_push!(test_data; 2.0, 0.0);
        cmplx_push!(test_data; 4.0, 0.0);
        cmplx_push!(test_data; 7.0, 0.0);

        fft_1d(&mut test_data, false);

        dbg!(&test_data);
    }
}
