/// maths libs
use num::complex::Complex;
use core::default::Default;
use std::error::Error;
/// standard libs
use std::f64::consts::PI;
use std::io::Read;
use std::vec;
/// libs for read images properly
/// jpg, png has its own encoding
/// need to parse the encoding
/// inorder to get correct rbg vectors
use minifb::{Window, WindowOptions};
use image::imageops::FilterType::Nearest;
use image::DynamicImage;
use image::ImageReader;


/// macro for new a complex number
macro_rules! cmplx_new {
    ($re: expr, $im: expr) => {{
        Complex::new($re, $im)
    }};
}

/// open a image file
/// return a dynamic image enum
/// input: filename
pub fn read_img(filename: &str) -> Result<DynamicImage, String> {
    let img = match ImageReader::open(filename) {
        Ok(img) => img,
        Err(e) => {
            return Err(e.to_string());
        }
    };

    let decoded_img = match img.decode() {
        Ok(img) => img,
        Err(e) => {
            return Err(e.to_string());
        }
    };
    Ok(decoded_img)
}

/// check if given number is base of 2
/// input n: int
pub fn is_base2(n: u32) -> bool {
    if (n & (n - 1)) == 0 {
        true
    } else {
        false
    }
}

/// resize image to the closest dimension
/// fft requires the dimensions of vectors to be base of 2
/// input
/// image: image object
/// height: int
/// width: int
pub fn img_resize(img: &DynamicImage, height: u32, width: u32) -> DynamicImage {
    let mut original_height = height as f32;
    let mut original_width = width as f32;

    let mut new_height = 2;
    let mut new_width = 2;

    let mut counter_r = 0;
    let mut counter_c = 0;

    while original_height / 2.0 > 1.0 {
        original_height /= 2.0;
        counter_c += 1;
    }

    while original_width / 2.0 > 1.0 {
        original_width /= 2.0;
        counter_r += 1;
    }

    while counter_c > 0 {
        new_height *= 2;
        counter_c -= 1;
    }

    while counter_r > 0 {
        new_width *= 2;
        counter_r -= 1;
    }


    img.resize(new_width, new_height, Nearest)
}


fn from_u8_rgb(r: u8, g: u8, b: u8) -> u32 {
    let (r, g, b) = (r as u32, g as u32, b as u32);
    (r << 16) | (g << 8) | b
}


/// restore complex number vector into f64 vector
fn complex2f64(v: Vec<Complex<f64>>) -> Vec<f64> {
    let mut vf64: Vec<f64> = Vec::new();
    for i in v.iter() {
        let changed: f64 = i.re / v.len() as f64;
        vf64.push(changed);
    }
    vf64
}

/// calculate the mod of complex number
// fn mod_complex(v: Vec<Complex<f64>>) -> Vec<f64> {
//     let mut rl32: Vec<f64> = Vec::new();
//     for i in v.iter() {
//         let moded_val = (i.re.powf(2.0) + i.im.powf(2.0)).sqrt();
//         rl32.push(moded_val);
//     }
//     rl32
// }

pub trait DisplayImage {
    fn display(&self, w: u32, h: u32) -> Result<(), Box<dyn Error>>;
}

impl DisplayImage for Vec<u32> {
    fn display(&self, w: u32, h: u32) -> Result<(), Box<dyn Error>> {
        let mut window = Window::new(
            "Display image",
            w as usize,
            h as usize,
            WindowOptions {
                resize: true,
                ..WindowOptions::default()
            },
        )?;
        window.set_target_fps(60);
        window.update_with_buffer(self, w as usize, h as usize)?;

        println!("Press Any Key to Continue");
        let _ = std::io::stdin().read(&mut [0]).unwrap();
        Ok(())
    }
}

/// https://cs.uwaterloo.ca/~kogeddes/cs487/LectureMaterials/Chapter_4_Materials/FFTalgorithm.pdf
/// http://paulbourke.net/miscellaneous/dft/
/// this is for fft a 1 dimensional vector
/// input
/// a: vector of complex numbers with im part 0
/// ifft is a flag to indicate if the value is inverse fft
/// changes vector reference `a' passed in to fourier coefficients generated by fft
fn fft_1d(a: &mut Vec<Complex<f64>>, ifft: bool) {
    let n = a.len();

    if n == 1 {
        return;
    }

    let mut a1: Vec<Complex<f64>> = vec![Default::default(); n >> 1];
    let mut a2: Vec<Complex<f64>> = vec![Default::default(); n >> 1];

    for i in (0..n).step_by(2) {
        a1[i >> 1] = a[i];
        a2[i >> 1] = a[i + 1];
    }

    fft_1d(&mut a1, ifft);
    fft_1d(&mut a2, ifft);

    let im_conjugate = if ifft { 1.0 } else { -1.0 };

    let omega_n: Complex<f64> = Complex::new(
        (2.0 * (PI as f64) / n as f64).cos(),
        im_conjugate * (2.0 * (PI as f64) / n as f64).sin(),
    );

    let mut omega = Complex::new(1.0, 0.0);

    for i in 0..n >> 1 {
        a[i] = a1[i] + omega * a2[i];
        a[i + (n >> 1)] = a1[i] - omega * a2[i];
        omega *= omega_n;
    }
}


pub fn fft_2d(img: DynamicImage, watermark: DynamicImage) {
    let width = img.width();
    let height = img.height();

    let new_img = img.clone();

    let n = (width * height) as usize;

    let rgb_vec = new_img
        .as_rgb8()
        .unwrap()
        .to_vec()
        .iter()
        .map(|&x| cmplx_new!(x as f64, 0f64))
        .collect::<Vec<Complex<f64>>>();

    let mut r_vec = Vec::new();
    let mut g_vec = Vec::new();
    let mut b_vec = Vec::new();

    for r in rgb_vec.iter().step_by(3) {
        r_vec.push(r.to_owned());
    }

    for g in rgb_vec.iter().skip(1).step_by(3) {
        g_vec.push(g.to_owned());
    }

    for b in rgb_vec.iter().skip(2).step_by(3) {
        b_vec.push(b.to_owned());
    }

    fft_1d(&mut r_vec, false);
    fft_1d(&mut g_vec, false);
    fft_1d(&mut b_vec, false);

    // process watermark
    let watermark_rgb_vec = watermark
        .as_rgb8()
        .unwrap()
        .to_vec()
        .iter()
        .map(|&x| cmplx_new!(x as f64, 0f64))
        .collect::<Vec<Complex<f64>>>();

    let mut watermark_r_vec = Vec::new();
    let mut watermark_g_vec = Vec::new();
    let mut watermark_b_vec = Vec::new();

    for r in watermark_rgb_vec.iter().step_by(3) {
        watermark_r_vec.push(r.to_owned());
    }

    for g in rgb_vec.iter().skip(1).step_by(3) {
        watermark_g_vec.push(g.to_owned());
    }

    for b in rgb_vec.iter().skip(2).step_by(3) {
        watermark_b_vec.push(b.to_owned());
    }

    // FFT
    fft_1d(&mut r_vec, false);
    fft_1d(&mut g_vec, false);
    fft_1d(&mut b_vec, false);

    fft_1d(&mut watermark_r_vec, false);
    fft_1d(&mut watermark_g_vec, false);
    fft_1d(&mut watermark_b_vec, false);

    // process img here
    // do a blending of original image and a watermark image
    for idx_r in 0..watermark_r_vec.len() {
        r_vec[idx_r] *= 0.2f64;
        r_vec[idx_r] += watermark_r_vec[idx_r] * 0.8f64;
    }

    for idx_g in 0..watermark_g_vec.len() {
        g_vec[idx_g] *= 0.2f64;
        g_vec[idx_g] += watermark_g_vec[idx_g] * 0.8f64;
        // g_vec[idx_g].re /= 2.0;
        // g_vec[idx_g].im /= 2.0;
    }

    for idx_b in 0..watermark_b_vec.len() {
        b_vec[idx_b] *= 0.2f64;
        b_vec[idx_b] += watermark_b_vec[idx_b] * 0.8f64;
        // b_vec[idx_b].re /= 2.0;
        // b_vec[idx_b].im /= 2.0;
    }

    // IFFT
    fft_1d(&mut r_vec, true);
    fft_1d(&mut g_vec, true);
    fft_1d(&mut b_vec, true);

    let r_f64 = complex2f64(r_vec);
    let g_f64 = complex2f64(g_vec);
    let b_f64 = complex2f64(b_vec);

    // let r_f64 = mod_complex(r_vec);
    // let g_f64 = mod_complex(g_vec);
    // let b_f64 = mod_complex(b_vec);

    let mut display_vec = Vec::new();
    for i in 0..n {
        let r = from_u8_rgb(r_f64[i] as u8, g_f64[i] as u8, b_f64[i] as u8);
        display_vec.push(r)
    }
    
    // display(width, height, &display_vec);
    match display_vec.display(width, height) {
        Ok(()) => (),
        Err(e) => {
            eprintln!("Error {}", e);
        }
    }
}


#[cfg(test)]
mod test {
    use super::*;

    macro_rules! cmplx_push {
        ($vec: expr; $re: expr, $im: expr) => {
            $vec.push(cmplx_new!($re, $im));
        };

        ($vec: expr, $cmplx: expr) => {
            $vec.push($cmplx);
        };
    }
    #[test]
    fn test_is_base2() {
        assert_eq!(is_base2(8), true);
    }

    #[test]
    fn test_not_base2() {
        assert_eq!(is_base2(9), false);
    }

    #[test]
    fn test_fft1d() {
        let mut test_data = Vec::new();

        cmplx_push!(test_data; 1.0, 0.0);
        cmplx_push!(test_data; 2.0, 0.0);
        cmplx_push!(test_data; 4.0, 0.0);
        cmplx_push!(test_data; 7.0, 0.0);

        fft_1d(&mut test_data, false);

        dbg!(&test_data);
    }
}
